/**
 * @file compiler.c
 * @brief Bytecode compiler for Kronos
 *
 * DESIGN DECISIONS:
 * - Single-pass compilation: AST is traversed once, generating bytecode
 *   directly. Simpler than multi-pass but requires forward references for
 *   jumps (we use placeholder offsets and patch them later).
 * - Constant pool: Shared constants (numbers, strings) are stored once in a
 *   pool and referenced by index. Reduces bytecode size and enables constant
 *   deduplication.
 * - Jump offset patching: Forward jumps (if, while, break, continue) require
 *   patching offsets after the target is known. We maintain lists of pending
 *   jumps and patch them when targets are compiled.
 * - Break/continue handling: Uses a loop stack to track active loops. Break/
 *   continue statements emit OP_JUMP with placeholder offsets, which are
 *   patched when the loop ends.
 * - No separate opcodes for break/continue: OP_BREAK/OP_CONTINUE are reserved
 *   but never emitted. We use OP_JUMP with patched offsets instead (keeps
 *   instruction set small).
 *
 * EDGE CASES:
 * - Forward references: Jump offsets patched after target compilation
 * - Nested loops: Loop stack tracks multiple active loops (break/continue
 *   applies to innermost loop)
 * - Jump offset overflow: INT16_MAX limit for jump offsets (would require
 *   larger bytecode, but extremely unlikely)
 * - Empty functions: Valid (emits OP_RETURN_VAL with nil if no return)
 * - Constant pool overflow: Not checked (would require SIZE_MAX check, but
 *   extremely unlikely)
 *
 * Converts Abstract Syntax Trees into bytecode instructions for the virtual
 * machine. Handles:
 * - Expression compilation (arithmetic, comparisons, logical operators)
 * - Statement compilation (assignments, control flow, functions)
 * - Constant pool management
 * - Jump offset patching for control flow
 * - Break/continue statement handling in loops
 */

#include "compiler.h"
#include <limits.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/**
 * Capacity constants for dynamic arrays
 *
 * DESIGN DECISIONS: 256 for bytecode (typical function < 256 bytes), 8/32 for
 * constant pool (grows to 32 on first constant), 4 for jump arrays (most loops
 * < 4 break/continue). All double when full (amortized O(1) append).
 */
#define BYTECODE_INITIAL_CAPACITY 256
#define CONSTANT_POOL_INITIAL_CAPACITY 8
#define CONSTANT_POOL_DEFAULT_CAPACITY 32
#define JUMP_ARRAY_INITIAL_CAPACITY 4

/**
 * Tracks a pending jump instruction that needs patching
 *
 * DESIGN DECISION: Linked list per loop for forward references. Emit OP_JUMP
 * with placeholder, patch when target known. Allows multiple break/continue
 * per loop.
 */
typedef struct BreakContinueJump {
  size_t jump_pos; // Position of jump offset byte that needs patching
  bool is_break;   // true for break, false for continue
  struct BreakContinueJump *next;
} BreakContinueJump;

/**
 * Tracks information about a loop for break/continue handling
 *
 * DESIGN DECISION: Stack-based (linked list) for arbitrary nesting. Each loop
 * pushes info, break/continue uses top, loop end pops. Matches lexical scoping.
 */
typedef struct LoopInfo {
  size_t loop_start;    // Position of loop start (for continue in while loops)
  size_t loop_continue; // Position to jump to for continue (increment for for
                        // loops, loop_start for while)
  size_t loop_end; // Position after loop end (for break) - updated after loop
                   // compilation
  BreakContinueJump *pending_jumps; // List of break/continue jumps to patch
  struct LoopInfo *next;
} LoopInfo;

/**
 * Compiler state structure
 * Tracks bytecode generation and error state
 */
typedef struct {
  Bytecode *bytecode;  /**< Generated bytecode being built */
  char *error_message; /**< Current error message (NULL if no error, dynamically
              allocated) */
  LoopInfo *loop_stack;       /**< Stack of active loops for break/continue */
  size_t to_string_const_idx; /**< Cache for "to_string" constant (SIZE_MAX if
               not created) */
  size_t loop_counter;        /**< Counter for unique iterator variable names */
} Compiler;

static inline bool compiler_has_error(const Compiler *c) {
  return c && c->error_message;
}

static void compiler_set_error(Compiler *c, const char *message) {
  if (!c || c->error_message) {
    return;
  }
  if (!message) {
    return;
  }
  // Copy the error message to avoid thread-safety issues with static buffers
  size_t len = strlen(message);
  c->error_message = malloc(len + 1);
  if (c->error_message) {
    strcpy(c->error_message, message);
  }
}

// Forward declarations for jump offset helpers
static size_t emit_jump_with_offset(Compiler *c, uint8_t opcode);
static void patch_jump_offset(Compiler *c, size_t offset_pos, int16_t offset);
static void patch_jump_offset_unsigned(Compiler *c, size_t offset_pos,
                                       uint16_t offset);

// Push loop info onto stack
static bool push_loop(Compiler *c, size_t loop_start) {
  LoopInfo *info = malloc(sizeof(LoopInfo));
  if (!info) {
    compiler_set_error(c, "Failed to allocate loop info");
    return false;
  }
  info->loop_start = loop_start;
  info->loop_continue =
      loop_start;     // Default to loop_start, will be updated for for loops
  info->loop_end = 0; // Will be set after loop compilation
  info->pending_jumps = NULL;
  info->next = c->loop_stack;
  c->loop_stack = info;
  // Increment loop counter for unique iterator variable names
  c->loop_counter++;
  return true;
}

// Add a pending break/continue jump to the current loop
static bool add_pending_jump(Compiler *c, size_t jump_pos, bool is_break) {
  if (!c->loop_stack) {
    compiler_set_error(c, is_break ? "break statement outside of loop"
                                   : "continue statement outside of loop");
    return false;
  }
  BreakContinueJump *jump = malloc(sizeof(BreakContinueJump));
  if (!jump) {
    compiler_set_error(c, "Failed to allocate jump info");
    return false;
  }
  jump->jump_pos = jump_pos;
  jump->is_break = is_break;
  jump->next = c->loop_stack->pending_jumps;
  c->loop_stack->pending_jumps = jump;
  return true;
}

// Patch all pending jumps for the current loop
static void patch_pending_jumps(Compiler *c) {
  if (!c->loop_stack) {
    return;
    // Process each node: update head before processing to avoid UAF on early
    // return
  }
  while (c->loop_stack->pending_jumps) {
    // Store next, advance head, then handle current
    BreakContinueJump *jump = c->loop_stack->pending_jumps;
    BreakContinueJump *next = jump->next;
    c->loop_stack->pending_jumps = next; // Update head before processing

    size_t target_pos =
        jump->is_break ? c->loop_stack->loop_end : c->loop_stack->loop_continue;
    // jump_pos points to the first byte of the 16-bit offset (after OP_JUMP)
    size_t offset = target_pos - (jump->jump_pos + 2);

    if (jump->is_break) {
      // Forward jump
      if (offset > INT16_MAX) {
        compiler_set_error(c, "break jump offset too large");
        free(jump); // Free current node before early return
        return;
      }
      patch_jump_offset(c, jump->jump_pos, (int16_t)offset);
    } else {
      // Backward jump for continue (or forward, but shouldn't happen)
      if (target_pos < jump->jump_pos + 2) {
        // Backward jump - calculate signed offset
        int16_t signed_offset = (int16_t)(target_pos - (jump->jump_pos + 2));
        patch_jump_offset(c, jump->jump_pos, signed_offset);
      } else {
        // Forward jump (shouldn't happen, but handle it)
        if (offset > INT16_MAX) {
          compiler_set_error(c, "continue jump offset too large");
          free(jump); // Free current node before early return
          return;
        }
        patch_jump_offset(c, jump->jump_pos, (int16_t)offset);
      }
    }
    free(jump); // Free current node after successful patching
  }
}

// Pop loop info from stack (frees pending jumps)
static void pop_loop(Compiler *c) {
  if (!c->loop_stack) {
    return;
    // Free any remaining pending jumps (shouldn't happen, but be safe)
  }
  BreakContinueJump *jump = c->loop_stack->pending_jumps;
  while (jump) {
    BreakContinueJump *next = jump->next;
    free(jump);
    jump = next;
  }
  LoopInfo *next = c->loop_stack->next;
  free(c->loop_stack);
  c->loop_stack = next;
}

/**
 * @brief Emit a single byte to the bytecode
 *
 * Automatically grows the bytecode buffer as needed.
 *
 * @param c Compiler state
 * @param byte Byte value to emit
 */
static void emit_byte(Compiler *c, uint8_t byte) {
  if (!c || compiler_has_error(c)) {
    return;
  }

  if (c->bytecode->count >= c->bytecode->capacity) {
    // Determine new capacity (minimum BYTECODE_INITIAL_CAPACITY if starting
    // from 0)
    size_t new_capacity;
    if (c->bytecode->capacity == 0) {
      new_capacity = BYTECODE_INITIAL_CAPACITY;
    } else {
      // Check for overflow before doubling capacity
      if (c->bytecode->capacity > SIZE_MAX / 2) {
        compiler_set_error(c, "Bytecode capacity overflow");
        return;
      }
      new_capacity = c->bytecode->capacity * 2;
    }

    // Calculate byte size safely (overflow already checked above)
    size_t new_size = new_capacity * sizeof(uint8_t);

    // Attempt reallocation using temporary pointer
    uint8_t *new_code = realloc(c->bytecode->code, new_size);

    if (!new_code) {
      compiler_set_error(c, "Failed to allocate memory for bytecode");
      return;
    }

    // Only update after successful reallocation
    c->bytecode->code = new_code;
    c->bytecode->capacity = new_capacity;
  }
  if (compiler_has_error(c)) {
    return;
  }

  c->bytecode->code[c->bytecode->count++] = byte;
}

// Note: emit_bytes() was removed as it's no longer used after switching to
// 16-bit jumps

/**
 * @brief Emit a 16-bit value in big-endian format
 *
 * Used for constant indices, variable indices, and jump offsets.
 *
 * @param c Compiler state
 * @param value 16-bit value to emit
 */
static void emit_uint16(Compiler *c, uint16_t value) {
  emit_byte(c, (uint8_t)((value >> 8) & 0xFF));
  emit_byte(c, (uint8_t)(value & 0xFF));
}

/**
 * @brief Emit a jump instruction with placeholder for 16-bit signed offset
 *
 * @param c Compiler state
 * @param opcode OP_JUMP or OP_JUMP_IF_FALSE
 * @return Position of the offset bytes (for later patching)
 */
static size_t emit_jump_with_offset(Compiler *c, uint8_t opcode) {
  emit_byte(c, opcode);
  size_t offset_pos = c->bytecode->count;
  emit_byte(c, 0); // Placeholder high byte
  emit_byte(c, 0); // Placeholder low byte
  return offset_pos;
}

/**
 * @brief Patch a 16-bit signed jump offset at the given position
 *
 * @param c Compiler state
 * @param offset_pos Position where offset bytes start
 * @param offset Signed 16-bit offset to write
 */
static void patch_jump_offset(Compiler *c, size_t offset_pos, int16_t offset) {
  c->bytecode->code[offset_pos] = (uint8_t)((offset >> 8) & 0xFF);
  c->bytecode->code[offset_pos + 1] = (uint8_t)(offset & 0xFF);
}

/**
 * @brief Patch a 16-bit unsigned jump offset at the given position
 *
 * @param c Compiler state
 * @param offset_pos Position where offset bytes start
 * @param offset Unsigned 16-bit offset to write
 */
static void patch_jump_offset_unsigned(Compiler *c, size_t offset_pos,
                                       uint16_t offset) {
  c->bytecode->code[offset_pos] = (uint8_t)((offset >> 8) & 0xFF);
  c->bytecode->code[offset_pos + 1] = (uint8_t)(offset & 0xFF);
}

/**
 * @brief Add a constant to the constant pool
 *
 * Constants are deduplicated - if the same value already exists,
 * returns its index. Otherwise adds a new entry.
 *
 * @param c Compiler state
 * @param value Value to add (ownership ALWAYS transferred - value is released
 *              if duplicate, retained if new)
 * @return Index in constant pool, or SIZE_MAX on error
 */
static size_t add_constant(Compiler *c, KronosValue *value) {
  if (!c || compiler_has_error(c)) {
    if (value) {
      value_release(value);
    }
    return SIZE_MAX;
  }

  if (!value) {
    compiler_set_error(c, "Cannot add NULL constant to pool");
    return SIZE_MAX;
  }

  if (c->bytecode->const_count >= c->bytecode->const_capacity) {
    // Determine new capacity (minimum CONSTANT_POOL_INITIAL_CAPACITY if
    // starting from 0)
    size_t new_capacity;
    if (c->bytecode->const_capacity == 0) {
      new_capacity = CONSTANT_POOL_INITIAL_CAPACITY;
    } else {
      // Check for overflow before doubling capacity
      // Use parentheses to ensure correct division order: SIZE_MAX / (2 *
      // sizeof(...))
      if (c->bytecode->const_capacity >
          SIZE_MAX / (2 * sizeof(KronosValue *))) {
        compiler_set_error(c, "Constant pool capacity overflow");
        value_release(value);
        return SIZE_MAX;
      }
      new_capacity = c->bytecode->const_capacity * 2;
    }

    // Calculate byte size safely (overflow already checked above)
    size_t new_size = new_capacity * sizeof(KronosValue *);

    // Attempt reallocation using temporary pointer
    KronosValue **new_constants = realloc(c->bytecode->constants, new_size);

    if (!new_constants) {
      compiler_set_error(c, "Failed to allocate memory for constant pool");
      value_release(value);
      return SIZE_MAX;
    }

    // Initialize new entries to NULL (realloc doesn't zero new memory)
    size_t old_capacity = c->bytecode->const_capacity;
    for (size_t i = old_capacity; i < new_capacity; i++) {
      new_constants[i] = NULL;
    }

    // Only update after successful reallocation
    c->bytecode->constants = new_constants;
    c->bytecode->const_capacity = new_capacity;
  }
  if (compiler_has_error(c)) {
    value_release(value);
    return SIZE_MAX;
  }

  // Check if this constant already exists (deduplication)
  for (size_t i = 0; i < c->bytecode->const_count; i++) {
    if (value_equals(c->bytecode->constants[i], value)) {
      // Found existing constant - return its index
      // Release the duplicate value since add_constant always takes ownership
      value_release(value);
      return i;
    }
  }

  // Not found - add new constant
  // Pool takes ownership of caller's reference - don't retain
  size_t idx = c->bytecode->const_count;
  c->bytecode->constants[idx] = value;
  c->bytecode->const_count++;

  return idx;
}

// Helper to emit constant
static void emit_constant(Compiler *c, KronosValue *value) {
  if (!c) {
    if (value) {
      value_release(value);
    }
    return;
  }

  // Check for errors BEFORE doing any work
  if (compiler_has_error(c)) {
    if (value) {
      value_release(value);
    }
    return;
  }

  // Validate value is not NULL
  if (!value) {
    compiler_set_error(c, "Cannot emit NULL constant");
    return;
  }

  size_t idx = add_constant(c, value);
  // add_constant() always takes ownership (releases if duplicate, takes
  // ownership if new)

  // Check for errors immediately after add_constant
  if (compiler_has_error(c)) {
    // add_constant already released the value on error
    return;
  }

  if (idx == SIZE_MAX) {
    // add_constant failed but didn't set error (shouldn't happen)
    compiler_set_error(c, "Failed to add constant to pool");
    // Value was already released by add_constant
    return;
  }

  if (idx > UINT16_MAX) {
    compiler_set_error(c, "Too many constants (limit 65535)");
    // Value was already released by add_constant
    return;
  }

  emit_byte(c, OP_LOAD_CONST);

  // Check for errors immediately
  if (compiler_has_error(c)) {
    return;
  }

  emit_uint16(c, (uint16_t)idx);

  // Check for errors immediately
  if (compiler_has_error(c)) {
    return;
  }

  // Success - add_constant already handled ownership
}

/**
 * @brief Add a constant to the pool and emit its index as uint16
 *
 * Helper function to reduce duplication. Handles the common pattern of:
 * - Creating a value
 * - Adding it to constant pool
 * - Checking for errors
 * - Emitting the index as uint16
 * - Releasing the value reference
 *
 * @param c Compiler state
 * @param value Value to add (ownership transferred, will be released)
 * @return true on success, false on error (error set in compiler)
 */
static bool emit_constant_index(Compiler *c, KronosValue *value) {
  if (!c) {
    if (value) {
      value_release(value);
    }
    return false;
  }

  // Check for errors BEFORE doing any work
  if (compiler_has_error(c)) {
    if (value) {
      value_release(value);
    }
    return false;
  }

  // Validate value is not NULL
  if (!value) {
    compiler_set_error(c, "Cannot add NULL constant to pool");
    return false;
  }

  size_t idx = add_constant(c, value);
  // add_constant() always takes ownership (releases if duplicate, takes
  // ownership if new)

  // Check for errors immediately after add_constant
  if (compiler_has_error(c)) {
    // add_constant already released the value on error
    return false;
  }

  if (idx == SIZE_MAX) {
    compiler_set_error(c, "Failed to add constant to pool");
    // Value was already released by add_constant
    return false;
  }

  if (idx > UINT16_MAX) {
    compiler_set_error(c, "Too many constants (limit 65535)");
    // Value was already released by add_constant
    return false;
  }

  emit_uint16(c, (uint16_t)idx);

  // Check for errors after emitting
  if (compiler_has_error(c)) {
    return false;
  }

  // Success - add_constant already handled ownership
  return true;
}

/**
 * @brief Get or create the "to_string" constant
 *
 * Caches the constant index to avoid recreating it multiple times.
 *
 * @param c Compiler state
 * @return Index of "to_string" constant, or SIZE_MAX on error
 */
static size_t get_to_string_constant(Compiler *c) {
  if (!c) {
    return SIZE_MAX;

    // Return cached value if already created
  }
  if (c->to_string_const_idx != SIZE_MAX) {
    return c->to_string_const_idx;
  }

  // Create and cache it
  KronosValue *to_string_name = value_new_string("to_string", 9);
  if (!to_string_name) {
    compiler_set_error(c, "Failed to allocate to_string constant");
    return SIZE_MAX;
  }

  size_t idx = add_constant(c, to_string_name);
  // add_constant() always takes ownership (releases if duplicate, retains if
  // new)

  if (idx == SIZE_MAX || idx > UINT16_MAX) {
    if (idx > UINT16_MAX) {
      compiler_set_error(c, "Too many constants");
    }
    return SIZE_MAX;
  }

  // Cache for future use
  c->to_string_const_idx = idx;
  return idx;
}

// Forward declarations for expression compilation helpers
static void compile_expression(Compiler *c, const ASTNode *node);
static void compile_number_expression(Compiler *c, const ASTNode *node);
static void compile_string_expression(Compiler *c, const ASTNode *node);
static void compile_bool_expression(Compiler *c, const ASTNode *node);
static void compile_nil_expression(Compiler *c, const ASTNode *node);
static void compile_var_expression(Compiler *c, const ASTNode *node);
static void compile_binop_expression(Compiler *c, const ASTNode *node);
static void compile_list_expression(Compiler *c, const ASTNode *node);
static void compile_map_expression(Compiler *c, const ASTNode *node);
static void compile_range_expression(Compiler *c, const ASTNode *node);
static void compile_index_expression(Compiler *c, const ASTNode *node);
static void compile_slice_expression(Compiler *c, const ASTNode *node);
static void compile_call_expression(Compiler *c, const ASTNode *node);
static void compile_fstring_expression(Compiler *c, const ASTNode *node);

// Forward declarations for statement compilation helpers
static void compile_statement(Compiler *c, const ASTNode *node);
static void compile_assign_statement(Compiler *c, const ASTNode *node);
static void compile_assign_index_statement(Compiler *c, const ASTNode *node);
static void compile_delete_statement(Compiler *c, const ASTNode *node);
static void compile_print_statement(Compiler *c, const ASTNode *node);
static void compile_return_statement(Compiler *c, const ASTNode *node);
static void compile_break_statement(Compiler *c, const ASTNode *node);
static void compile_continue_statement(Compiler *c, const ASTNode *node);
static void compile_raise_statement(Compiler *c, const ASTNode *node);
static void compile_call_statement(Compiler *c, const ASTNode *node);
static void compile_import_statement(Compiler *c, const ASTNode *node);
static void compile_if_statement(Compiler *c, const ASTNode *node);
static void compile_while_statement(Compiler *c, const ASTNode *node);
static void compile_for_statement(Compiler *c, const ASTNode *node);
static void compile_function_statement(Compiler *c, const ASTNode *node);
static void compile_try_statement(Compiler *c, const ASTNode *node);

/**
 * @brief Compile a number literal expression
 */
static void compile_number_expression(Compiler *c, const ASTNode *node) {
  KronosValue *val = value_new_number(node->as.number);
  emit_constant(c, val);
}

/**
 * @brief Compile a string literal expression
 */
static void compile_string_expression(Compiler *c, const ASTNode *node) {
  KronosValue *val =
      value_new_string(node->as.string.value, node->as.string.length);
  if (!val) {
    compiler_set_error(c, "Failed to allocate string constant");
    return;
  }
  emit_constant(c, val);
}

/**
 * @brief Compile a boolean literal expression
 */
static void compile_bool_expression(Compiler *c, const ASTNode *node) {
  KronosValue *val = value_new_bool(node->as.boolean);
  emit_constant(c, val);
}

/**
 * @brief Compile a nil literal expression
 */
static void compile_nil_expression(Compiler *c, const ASTNode *node) {
  (void)node; // Unused parameter
  KronosValue *val = value_new_nil();
  emit_constant(c, val);
}

/**
 * @brief Compile a variable reference expression
 */
static void compile_var_expression(Compiler *c, const ASTNode *node) {
  KronosValue *name =
      value_new_string(node->as.var_name, strlen(node->as.var_name));
  emit_byte(c, OP_LOAD_VAR);
  if (!emit_constant_index(c, name)) {
    return;
  }
}

/**
 * @brief Compile a list literal expression
 */
static void compile_list_expression(Compiler *c, const ASTNode *node) {
  // Compile list literal: list 1, 2, 3
  // Create empty list first
  emit_byte(c, OP_LIST_NEW);
  emit_uint16(c, 0); // Start with empty list
  if (compiler_has_error(c)) {
    return;
  }

  // Compile each element and append in order
  for (size_t i = 0; i < node->as.list.element_count; i++) {
    // Push list, then element, then append
    // List is already on stack from OP_LIST_NEW or previous append
    // So we need to duplicate it before each append
    // Actually, OP_LIST_APPEND should leave the list on stack
    compile_expression(c, node->as.list.elements[i]);
    if (compiler_has_error(c)) {
      return;
    }
    // Stack: [list, element]
    // OP_LIST_APPEND: pop element, pop list, append, push list
    emit_byte(c, OP_LIST_APPEND);
    if (compiler_has_error(c)) {
      return;
    }
  }
}

/**
 * @brief Compile a range literal expression
 */
static void compile_range_expression(Compiler *c, const ASTNode *node) {
  // Compile range literal: range start to end [by step]
  // Compile start, end, and step (if provided) expressions
  compile_expression(c, node->as.range.start);
  if (compiler_has_error(c)) {
    return;
  }

  compile_expression(c, node->as.range.end);
  if (compiler_has_error(c)) {
    return;
  }

  if (node->as.range.step) {
    compile_expression(c, node->as.range.step);
    if (compiler_has_error(c)) {
      return;
    }
  } else {
    // Default step is 1.0
    KronosValue *one = value_new_number(1.0);
    size_t step_idx = add_constant(c, one);
    // add_constant() always takes ownership
    if (step_idx == SIZE_MAX || step_idx > UINT16_MAX) {
      return;
    }
    emit_byte(c, OP_LOAD_CONST);
    emit_uint16(c, (uint16_t)step_idx);
    if (compiler_has_error(c)) {
      return;
    }
  }

  // Stack: [start, end, step]
  // OP_RANGE_NEW: pop step, pop end, pop start, create range, push range
  emit_byte(c, OP_RANGE_NEW);
  if (compiler_has_error(c)) {
    return;
  }
}

/**
 * @brief Compile a map literal expression
 */
static void compile_map_expression(Compiler *c, const ASTNode *node) {
  // Compile map literal: map key: value, key2: value2
  // Create empty map first
  emit_byte(c, OP_MAP_NEW);
  emit_uint16(c, 0); // Start with empty map
  if (compiler_has_error(c)) {
    return;
  }

  // Compile each key-value pair and set in order
  for (size_t i = 0; i < node->as.map.entry_count; i++) {
    // Stack: [map]
    // Compile key
    compile_expression(c, node->as.map.keys[i]);
    if (compiler_has_error(c)) {
      return;
    }
    // Stack: [map, key]
    // Compile value
    compile_expression(c, node->as.map.values[i]);
    if (compiler_has_error(c)) {
      return;
    }
    // Stack: [map, key, value]
    // OP_MAP_SET: pop value, pop key, pop map, set, push map
    emit_byte(c, OP_MAP_SET);
    if (compiler_has_error(c)) {
      return;
    }
    // Stack: [map]
  }
}

/**
 * @brief Compile an index expression
 */
static void compile_index_expression(Compiler *c, const ASTNode *node) {
  // Compile indexing: list at index
  compile_expression(c, node->as.index.list_expr);
  if (compiler_has_error(c)) {
    return;
  }
  compile_expression(c, node->as.index.index);
  if (compiler_has_error(c)) {
    return;
  }
  emit_byte(c, OP_LIST_GET);
}

/**
 * @brief Compile a slice expression
 */
static void compile_slice_expression(Compiler *c, const ASTNode *node) {
  // Compile slicing: container from start to end
  compile_expression(c, node->as.slice.list_expr);
  if (compiler_has_error(c)) {
    return;
  }
  compile_expression(c, node->as.slice.start);
  if (compiler_has_error(c)) {
    return;
  }

  if (node->as.slice.end) {
    // Explicit end: compile end expression
    compile_expression(c, node->as.slice.end);
    if (compiler_has_error(c)) {
      return;
    }
  } else {
    // Implicit end (to end): push -1 as marker
    KronosValue *end_marker = value_new_number(-1);
    size_t end_idx = add_constant(c, end_marker);
    // add_constant() always takes ownership
    if (end_idx == SIZE_MAX || end_idx > UINT16_MAX) {
      return;
    }
    emit_byte(c, OP_LOAD_CONST);
    emit_uint16(c, (uint16_t)end_idx);
    if (compiler_has_error(c)) {
      return;
    }
  }

  emit_byte(c, OP_LIST_SLICE);
}

/**
 * @brief Compile an f-string expression
 */
static void compile_fstring_expression(Compiler *c, const ASTNode *node) {
  // Compile f-string by concatenating parts
  // parts alternate: string, expr, string, expr, ...
  // Start with first string (or empty string if first is expr)
  if (node->as.fstring.part_count == 0) {
    // Empty f-string
    KronosValue *empty = value_new_string("", 0);
    if (!empty) {
      compiler_set_error(c, "Failed to allocate empty string constant");
      return;
    }
    emit_constant(c, empty);
    return;
  }

  // Compile first part
  ASTNode *first_part = node->as.fstring.parts[0];
  if (first_part->type == AST_STRING) {
    // First part is a string - emit it
    compile_expression(c, first_part);
    if (compiler_has_error(c)) {
      return;
    }
  } else {
    // First part is an expression - start with empty string
    KronosValue *empty = value_new_string("", 0);
    if (!empty) {
      compiler_set_error(c, "Failed to allocate empty string constant");
      return;
    }
    emit_constant(c, empty);
    if (compiler_has_error(c)) {
      return;
    }
    // Then compile expression, convert to string, and concatenate
    compile_expression(c, first_part);
    if (compiler_has_error(c)) {
      return;
    }

    // Call to_string to convert expression result to string
    size_t to_string_idx = get_to_string_constant(c);
    if (to_string_idx == SIZE_MAX) {
      return;
    }
    emit_byte(c, OP_CALL_FUNC);
    if (compiler_has_error(c)) {
      return;
    }
    emit_uint16(c, (uint16_t)to_string_idx);
    if (compiler_has_error(c)) {
      return;
    }
    emit_byte(c, 1); // 1 argument
    if (compiler_has_error(c)) {
      return;
    }

    emit_byte(c, OP_ADD);
    if (compiler_has_error(c)) {
      return;
    }
  }

  // Process remaining parts (pairs of expr, string)
  for (size_t i = 1; i < node->as.fstring.part_count; i++) {
    ASTNode *part = node->as.fstring.parts[i];

    if (part->type == AST_STRING) {
      // String literal - just compile it
      compile_expression(c, part);
      if (compiler_has_error(c)) {
        return;
      }
    } else {
      // Expression - compile it and convert to string
      compile_expression(c, part);
      if (compiler_has_error(c)) {
        return;
      }

      // Call to_string to convert expression result to string
      size_t to_string_idx = get_to_string_constant(c);
      if (to_string_idx == SIZE_MAX) {
        return;
      }
      emit_byte(c, OP_CALL_FUNC);
      emit_uint16(c, (uint16_t)to_string_idx);
      emit_byte(c, 1); // 1 argument
      if (compiler_has_error(c)) {
        return;
      }
    }

    emit_byte(c, OP_ADD); // Concatenate
    if (compiler_has_error(c)) {
      return;
    }
  }
}

/**
 * @brief Compile a function call expression
 */
static void compile_call_expression(Compiler *c, const ASTNode *node) {
  // Compile function call as expression
  // Push arguments onto stack (in order)
  for (size_t i = 0; i < node->as.call.arg_count; i++) {
    compile_expression(c, node->as.call.args[i]);
    if (compiler_has_error(c)) {
      return;
    }
  }

  // Emit call instruction
  KronosValue *func_name =
      value_new_string(node->as.call.name, strlen(node->as.call.name));
  emit_byte(c, OP_CALL_FUNC);
  if (!emit_constant_index(c, func_name)) {
    return;
  }
  // Validate argument count limit (uint8_t max is 255)
  if (node->as.call.arg_count > 255) {
    compiler_set_error(c, "Function call argument count exceeds limit (255)");
    return;
  }
  emit_byte(c, (uint8_t)node->as.call.arg_count);
  if (compiler_has_error(c)) {
    return;
  }
}

/**
 * @brief Compile a binary operator expression
 */
static void compile_binop_expression(Compiler *c, const ASTNode *node) {
  // Handle unary operators (NOT and NEG) - right is NULL
  if (node->as.binop.op == BINOP_NOT) {
    compile_expression(c, node->as.binop.left);
    if (compiler_has_error(c)) {
      return;
    }
    emit_byte(c, OP_NOT);
    return;
  }
  if (node->as.binop.op == BINOP_NEG) {
    compile_expression(c, node->as.binop.left);
    if (compiler_has_error(c)) {
      return;
    }
    emit_byte(c, OP_NEG);
    return;
  }

  // Compile left and right operands for binary operators
  compile_expression(c, node->as.binop.left);
  if (compiler_has_error(c)) {
    return;
  }
  compile_expression(c, node->as.binop.right);
  if (compiler_has_error(c)) {
    return;
  }

  // Emit operator (arithmetic, comparison, or logical)
  switch (node->as.binop.op) {
  case BINOP_ADD:
    emit_byte(c, OP_ADD);
    break;
  case BINOP_SUB:
    emit_byte(c, OP_SUB);
    break;
  case BINOP_MUL:
    emit_byte(c, OP_MUL);
    break;
  case BINOP_DIV:
    emit_byte(c, OP_DIV);
    break;
  case BINOP_MOD:
    emit_byte(c, OP_MOD);
    break;
  case BINOP_EQ:
    emit_byte(c, OP_EQ);
    break;
  case BINOP_NEQ:
    emit_byte(c, OP_NEQ);
    break;
  case BINOP_GT:
    emit_byte(c, OP_GT);
    break;
  case BINOP_LT:
    emit_byte(c, OP_LT);
    break;
  case BINOP_GTE:
    emit_byte(c, OP_GTE);
    break;
  case BINOP_LTE:
    emit_byte(c, OP_LTE);
    break;
  case BINOP_AND:
    emit_byte(c, OP_AND);
    break;
  case BINOP_OR:
    emit_byte(c, OP_OR);
    break;
  default: {
    // Report error for unsupported/unknown binary operator
    // Use local buffer instead of static to avoid thread-safety issues
    char error_buf[128];
    snprintf(error_buf, sizeof(error_buf),
             "Unsupported binary operator (enum value: %d)", node->as.binop.op);
    compiler_set_error(c, error_buf);
    return; // Return early to avoid stack imbalance
  }
  }
}

/**
 * @brief Compile an expression AST node to bytecode
 *
 * Recursively compiles expressions, emitting instructions that leave
 * the result on the VM stack.
 *
 * @param c Compiler state
 * @param node Expression AST node to compile (not modified)
 */
static void compile_expression(Compiler *c, const ASTNode *node) {
  if (!node || compiler_has_error(c)) {
    return;
  }

  switch (node->type) {
  case AST_NUMBER:
    compile_number_expression(c, node);
    break;

  case AST_STRING:
    compile_string_expression(c, node);
    break;

  case AST_FSTRING:
    compile_fstring_expression(c, node);
    break;

  case AST_BOOL:
    compile_bool_expression(c, node);
    break;

  case AST_NULL:
    compile_nil_expression(c, node);
    break;

  case AST_VAR:
    compile_var_expression(c, node);
    break;

  case AST_BINOP:
    compile_binop_expression(c, node);
    break;

  case AST_LIST:
    compile_list_expression(c, node);
    break;

  case AST_RANGE:
    compile_range_expression(c, node);
    break;

  case AST_MAP:
    compile_map_expression(c, node);
    break;

  case AST_INDEX:
    compile_index_expression(c, node);
    break;

  case AST_SLICE:
    compile_slice_expression(c, node);
    break;

  case AST_CALL:
    compile_call_expression(c, node);
    break;

  default:
    compiler_set_error(c, "Unknown expression node type");
    break;
  }
}

/**
 * @brief Compile an assignment statement
 */
static void compile_assign_statement(Compiler *c, const ASTNode *node) {
  // Compile value expression
  compile_expression(c, node->as.assign.value);
  if (compiler_has_error(c)) {
    return;
  }

  // Store in variable
  KronosValue *name =
      value_new_string(node->as.assign.name, strlen(node->as.assign.name));
  emit_byte(c, OP_STORE_VAR);
  if (!emit_constant_index(c, name)) {
    return;
  }
  if (compiler_has_error(c)) {
    return;
  }

  // Emit mutability flag (1 byte: 1 for mutable, 0 for immutable)
  emit_byte(c, node->as.assign.is_mutable ? 1 : 0);
  if (compiler_has_error(c)) {
    return;
  }

  // Emit type name if specified
  if (node->as.assign.type_name) {
    emit_byte(c, 1);
    KronosValue *type_val = value_new_string(node->as.assign.type_name,
                                             strlen(node->as.assign.type_name));
    if (!emit_constant_index(c, type_val)) {
      return;
    }
  } else {
    emit_byte(c, 0); // no type specified
  }
  if (compiler_has_error(c)) {
    return;
  }
}

/**
 * @brief Compile an indexed assignment statement
 */
static void compile_assign_index_statement(Compiler *c, const ASTNode *node) {
  // Compile target (variable)
  compile_expression(c, node->as.assign_index.target);
  if (compiler_has_error(c)) {
    return;
  }

  // Compile index expression
  compile_expression(c, node->as.assign_index.index);
  if (compiler_has_error(c)) {
    return;
  }

  // Compile value expression
  compile_expression(c, node->as.assign_index.value);
  if (compiler_has_error(c)) {
    return;
  }

  // Emit OP_LIST_SET instruction
  emit_byte(c, OP_LIST_SET);
  if (compiler_has_error(c)) {
    return;
  }
}

/**
 * @brief Compile a delete statement
 */
static void compile_delete_statement(Compiler *c, const ASTNode *node) {
  // Compile target (variable)
  compile_expression(c, node->as.delete_stmt.target);
  if (compiler_has_error(c)) {
    return;
  }

  // Compile key expression
  compile_expression(c, node->as.delete_stmt.key);
  if (compiler_has_error(c)) {
    return;
  }

  // Emit OP_DELETE instruction
  emit_byte(c, OP_DELETE);
  if (compiler_has_error(c)) {
    return;
  }
}

/**
 * @brief Compile a print statement
 */
static void compile_print_statement(Compiler *c, const ASTNode *node) {
  // Compile value expression
  compile_expression(c, node->as.print.value);
  if (compiler_has_error(c)) {
    return;
  }

  // Emit print instruction
  emit_byte(c, OP_PRINT);
  if (compiler_has_error(c)) {
    return;
  }
}

/**
 * @brief Compile a return statement
 */
static void compile_return_statement(Compiler *c, const ASTNode *node) {
  // Compile return value
  compile_expression(c, node->as.return_stmt.value);
  if (compiler_has_error(c)) {
    return;
  }
  emit_byte(c, OP_RETURN_VAL);
  if (compiler_has_error(c)) {
    return;
  }
}

/**
 * @brief Compile a break statement
 */
static void compile_break_statement(Compiler *c, const ASTNode *node) {
  (void)node; // Unused parameter
  // Break out of loop - jump to loop end (will be patched after loop
  // compilation)
  size_t jump_pos = emit_jump_with_offset(c, OP_JUMP);
  if (compiler_has_error(c)) {
    return;
  }
  // Add to pending jumps list (jump_pos points to first byte of offset)
  if (!add_pending_jump(c, jump_pos, true)) {
    return;
  }
}

/**
 * @brief Compile a continue statement
 */
static void compile_continue_statement(Compiler *c, const ASTNode *node) {
  (void)node; // Unused parameter
  // Continue to next loop iteration - jump to loop start (will be patched
  // after loop compilation)
  size_t jump_pos = emit_jump_with_offset(c, OP_JUMP);
  if (compiler_has_error(c)) {
    return;
  }
  // Add to pending jumps list (jump_pos points to first byte of offset)
  if (!add_pending_jump(c, jump_pos, false)) {
    return;
  }
}

/**
 * @brief Compile a raise statement
 */
static void compile_raise_statement(Compiler *c, const ASTNode *node) {
  // Compile error message expression
  compile_expression(c, node->as.raise_stmt.message);
  if (compiler_has_error(c)) {
    return;
  }

  // Emit OP_THROW with error type constant
  emit_byte(c, OP_THROW);

  // Error type constant (or 0xFFFF for generic Error)
  if (node->as.raise_stmt.error_type) {
    KronosValue *error_type_val = value_new_string(
        node->as.raise_stmt.error_type, strlen(node->as.raise_stmt.error_type));
    if (!emit_constant_index(c, error_type_val)) {
      return;
    }
  } else {
    // Generic Error type
    emit_uint16(c, 0xFFFF);
  }
}

/**
 * @brief Compile a function call statement (discards return value)
 */
static void compile_call_statement(Compiler *c, const ASTNode *node) {
  // Push arguments onto stack
  for (size_t i = 0; i < node->as.call.arg_count; i++) {
    compile_expression(c, node->as.call.args[i]);
    if (compiler_has_error(c)) {
      return;
    }
  }

  // Push function name
  KronosValue *func_name =
      value_new_string(node->as.call.name, strlen(node->as.call.name));
  emit_byte(c, OP_CALL_FUNC);
  if (!emit_constant_index(c, func_name)) {
    return;
  }
  if (compiler_has_error(c)) {
    return;
  }
  // Validate argument count limit (uint8_t max is 255)
  if (node->as.call.arg_count > 255) {
    compiler_set_error(c, "Function call argument count exceeds limit (255)");
    return;
  }
  emit_byte(c, (uint8_t)node->as.call.arg_count);
  if (compiler_has_error(c)) {
    return;
  }

  // For built-in functions, print the result instead of discarding it
  // For user-defined functions, pop the return value (function calls as
  // statements don't use the return value)
  const char *func_name_str = node->as.call.name;
  if (strcmp(func_name_str, "add") == 0 ||
      strcmp(func_name_str, "subtract") == 0 ||
      strcmp(func_name_str, "multiply") == 0 ||
      strcmp(func_name_str, "divide") == 0 ||
      strcmp(func_name_str, "len") == 0) {
    emit_byte(c, OP_PRINT);
  } else {
    emit_byte(c, OP_POP);
  }
  if (compiler_has_error(c)) {
    return;
  }
}

/**
 * @brief Compile an import statement
 */
static void compile_import_statement(Compiler *c, const ASTNode *node) {
  // Emit OP_IMPORT instruction with module name and file path as constant
  // indices
  emit_byte(c, OP_IMPORT);

  // Add module name to constant pool and emit index
  KronosValue *module_name_val = value_new_string(
      node->as.import.module_name, strlen(node->as.import.module_name));
  if (!module_name_val) {
    compiler_set_error(c, "Failed to create module name constant");
    return;
  }
  if (!emit_constant_index(c, module_name_val)) {
    compiler_set_error(c, "Failed to add module name constant");
    return;
  }

  // Add file path to constant pool and emit index (nil for built-in modules)
  KronosValue *file_path_val = NULL;
  if (node->as.import.file_path) {
    file_path_val = value_new_string(node->as.import.file_path,
                                     strlen(node->as.import.file_path));
    if (!file_path_val) {
      compiler_set_error(c, "Failed to create file path constant");
      return;
    }
  } else {
    // NULL for built-in modules
    file_path_val = value_new_nil();
    if (!file_path_val) {
      compiler_set_error(c, "Failed to create nil constant");
      return;
    }
  }
  if (!emit_constant_index(c, file_path_val)) {
    compiler_set_error(c, "Failed to add file path constant");
    return;
  }
}

/**
 * @brief Compile an if statement (with else-if chains and else)
 */
static void compile_if_statement(Compiler *c, const ASTNode *node) {
  // Compile condition
  compile_expression(c, node->as.if_stmt.condition);
  if (compiler_has_error(c)) {
    return;
  }

  // Emit jump if false (placeholder for jump offset)
  size_t jump_offset_pos = emit_jump_with_offset(c, OP_JUMP_IF_FALSE);
  if (compiler_has_error(c)) {
    return;
  }

  // Compile if block
  for (size_t i = 0; i < node->as.if_stmt.block_size; i++) {
    compile_statement(c, node->as.if_stmt.block[i]);
    if (compiler_has_error(c)) {
      return;
    }
  }

  // Collect all jump positions that need to be patched to point to next
  // condition/else/end
  size_t *jump_positions = NULL;
  size_t jump_count = 0;
  size_t jump_capacity = 0;

  // Collect all skip jumps (jumps that skip to the end)
  size_t *skip_jumps = NULL;
  size_t skip_count = 0;
  size_t skip_capacity = 0;

  // Add the initial if jump (jump-if-false, should point to next
  // else-if/else/end)
  if (jump_count >= jump_capacity) {
    size_t new_capacity =
        jump_capacity == 0 ? JUMP_ARRAY_INITIAL_CAPACITY : jump_capacity * 2;
    size_t *new_positions =
        realloc(jump_positions, sizeof(size_t) * new_capacity);
    if (!new_positions) {
      compiler_set_error(c, "Failed to allocate jump positions array");
      return;
    }
    jump_positions = new_positions;
    jump_capacity = new_capacity;
  }
  jump_positions[jump_count++] = jump_offset_pos;

  // Only emit skip jump if there are else-if or else blocks
  // For simple if statements, we don't need a skip jump
  bool has_else_or_else_if = (node->as.if_stmt.else_if_count > 0 ||
                              node->as.if_stmt.else_block_size > 0);

  if (has_else_or_else_if) {
    // Emit skip jump at end of if block (will be patched at the end)
    size_t if_skip_jump_pos = emit_jump_with_offset(c, OP_JUMP);
    if (compiler_has_error(c)) {
      free(jump_positions);
      return;
    }
    if (skip_count >= skip_capacity) {
      size_t new_capacity =
          skip_capacity == 0 ? JUMP_ARRAY_INITIAL_CAPACITY : skip_capacity * 2;
      size_t *new_skips = realloc(skip_jumps, sizeof(size_t) * new_capacity);
      if (!new_skips) {
        compiler_set_error(c, "Failed to allocate skip jumps array");
        free(jump_positions);
        return;
      }
      skip_jumps = new_skips;
      skip_capacity = new_capacity;
    }
    skip_jumps[skip_count++] = if_skip_jump_pos;
  }

  // Compile else-if chains
  for (size_t i = 0; i < node->as.if_stmt.else_if_count; i++) {
    // Patch previous jumps to point to this else-if condition
    size_t else_if_start = c->bytecode->count;
    for (size_t j = 0; j < jump_count; j++) {
      size_t pos = jump_positions[j];
      int16_t offset = (int16_t)(else_if_start - (pos + 2));
      if (offset < INT16_MIN || offset > INT16_MAX) {
        compiler_set_error(c, "Jump offset too large in if statement");
        free(jump_positions);
        free(skip_jumps);
        return;
      }
      patch_jump_offset(c, pos, offset);
    }
    // Clear jump positions - we'll add new ones for this else-if
    jump_count = 0;

    // Compile else-if condition
    compile_expression(c, node->as.if_stmt.else_if_conditions[i]);
    if (compiler_has_error(c)) {
      free(jump_positions);
      free(skip_jumps);
      return;
    }

    // Emit jump if false
    size_t else_if_jump_if_false_pos =
        emit_jump_with_offset(c, OP_JUMP_IF_FALSE);
    if (compiler_has_error(c)) {
      free(jump_positions);
      free(skip_jumps);
      return;
    }

    // Compile else-if block
    for (size_t j = 0; j < node->as.if_stmt.else_if_block_sizes[i]; j++) {
      compile_statement(c, node->as.if_stmt.else_if_blocks[i][j]);
      if (compiler_has_error(c)) {
        free(jump_positions);
        free(skip_jumps);
        return;
      }
    }

    // Emit skip jump AFTER the else-if block body (to skip to end when this
    // branch executes)
    size_t else_if_skip_jump_pos = emit_jump_with_offset(c, OP_JUMP);
    if (compiler_has_error(c)) {
      free(jump_positions);
      free(skip_jumps);
      return;
    }

    // Add skip jump to list (will be patched at the end)
    if (skip_count >= skip_capacity) {
      size_t new_capacity =
          skip_capacity == 0 ? JUMP_ARRAY_INITIAL_CAPACITY : skip_capacity * 2;
      size_t *new_skips = realloc(skip_jumps, sizeof(size_t) * new_capacity);
      if (!new_skips) {
        compiler_set_error(c, "Failed to allocate skip jumps array");
        free(jump_positions);
        free(skip_jumps);
        return;
      }
      skip_jumps = new_skips;
      skip_capacity = new_capacity;
    }
    skip_jumps[skip_count++] = else_if_skip_jump_pos;

    // Add jump-if-false to list (should point to next else-if/else/end)
    if (jump_count + 1 > jump_capacity) {
      size_t new_capacity =
          jump_capacity == 0 ? JUMP_ARRAY_INITIAL_CAPACITY : jump_capacity * 2;
      while (new_capacity < jump_count + 1) {
        new_capacity *= 2;
      }
      size_t *new_positions =
          realloc(jump_positions, sizeof(size_t) * new_capacity);
      if (!new_positions) {
        compiler_set_error(c, "Failed to allocate jump positions array");
        free(jump_positions);
        free(skip_jumps);
        return;
      }
      jump_positions = new_positions;
      jump_capacity = new_capacity;
    }
    jump_positions[jump_count++] = else_if_jump_if_false_pos;
  }

  // Compile else block (if present)
  if (node->as.if_stmt.else_block_size > 0) {
    // Patch all previous jumps (from if and else-if chains) to point to else
    // block
    size_t else_start = c->bytecode->count;
    for (size_t j = 0; j < jump_count; j++) {
      size_t pos = jump_positions[j];
      int16_t offset = (int16_t)(else_start - (pos + 2));
      if (offset < INT16_MIN || offset > INT16_MAX) {
        compiler_set_error(c, "Jump offset too large in if statement");
        free(jump_positions);
        free(skip_jumps);
        return;
      }
      patch_jump_offset(c, pos, offset);
    }
    jump_count = 0;

    // Compile else block
    for (size_t i = 0; i < node->as.if_stmt.else_block_size; i++) {
      compile_statement(c, node->as.if_stmt.else_block[i]);
      if (compiler_has_error(c)) {
        free(jump_positions);
        free(skip_jumps);
        return;
      }
    }
  }

  // Patch all skip jumps to point to end
  size_t end_pos = c->bytecode->count;
  for (size_t j = 0; j < skip_count; j++) {
    size_t pos = skip_jumps[j];
    int16_t offset = (int16_t)(end_pos - (pos + 2));
    if (offset < INT16_MIN || offset > INT16_MAX) {
      compiler_set_error(c, "Jump offset too large in if statement");
      free(jump_positions);
      free(skip_jumps);
      return;
    }
    patch_jump_offset(c, pos, offset);
  }

  // If no else block, also patch jump-if-false jumps to end
  if (node->as.if_stmt.else_block_size == 0) {
    for (size_t j = 0; j < jump_count; j++) {
      size_t pos = jump_positions[j];
      int16_t offset = (int16_t)(end_pos - (pos + 2));
      if (offset < INT16_MIN || offset > INT16_MAX) {
        compiler_set_error(c, "Jump offset too large in if statement");
        free(jump_positions);
        free(skip_jumps);
        return;
      }
      patch_jump_offset(c, pos, offset);
    }
  }

  free(jump_positions);
  free(skip_jumps);
}

/**
 * @brief Compile a for loop statement (range or list iteration)
 */
static void compile_for_statement(Compiler *c, const ASTNode *node) {
  KronosValue *var_name =
      value_new_string(node->as.for_stmt.var, strlen(node->as.for_stmt.var));
  // Get variable index once - it's used multiple times in the loop
  size_t var_idx = add_constant(c, var_name);
  // add_constant() always takes ownership
  if (var_idx == SIZE_MAX) {
    return;
  }
  if (var_idx > UINT16_MAX) {
    compiler_set_error(c, "Too many constants (limit 65535)");
    return;
  }

  if (node->as.for_stmt.is_range) {
    // Range iteration: for i in range start to end [by step]
    // Initialize loop variable
    compile_expression(c, node->as.for_stmt.iterable);
    if (compiler_has_error(c)) {
      return;
    }
    emit_byte(c, OP_STORE_VAR);
    emit_uint16(c, (uint16_t)var_idx);
    emit_byte(c, 1); // for loop variables default mutable
    emit_byte(c, 0); // no type annotation
    if (compiler_has_error(c)) {
      return;
    }

    // Loop start
    size_t loop_start = c->bytecode->count;

    // Load loop variable and end value
    emit_byte(c, OP_LOAD_VAR);
    emit_uint16(c, (uint16_t)var_idx);
    if (compiler_has_error(c)) {
      return;
    }
    compile_expression(c, node->as.for_stmt.end);
    if (compiler_has_error(c)) {
      return;
    }

    // Determine step value (default to 1 if not specified)
    // If step is NULL, we'll use 1
    bool has_step = (node->as.for_stmt.step != NULL);

    // For comparison, we need to check direction based on step
    // If step > 0: check var <= end
    // If step < 0: check var >= end
    bool use_gte = false; // Default to LTE for positive steps
    bool step_is_constant = false;

    if (has_step && node->as.for_stmt.step->type == AST_NUMBER) {
      // Step is a constant - check if it's negative at compile time
      step_is_constant = true;
      if (node->as.for_stmt.step->as.number < 0.0) {
        use_gte = true; // Use >= for negative steps
      }
    }

    // For non-constant steps, check step sign at runtime
    if (has_step && !step_is_constant) {
      // Evaluate step expression to check its sign
      compile_expression(c, node->as.for_stmt.step);
      if (compiler_has_error(c)) {
        return;
      }

      // Compare step to 0: step < 0
      // Stack before: [var, end, step]
      KronosValue *zero = value_new_number(0);
      emit_constant(c, zero);
      if (compiler_has_error(c)) {
        return;
      }
      // Stack: [var, end, step, 0]
      emit_byte(c, OP_LT); // Compares step < 0, pops step and 0, pushes bool
      // Stack: [var, end, (step < 0)]
      if (compiler_has_error(c)) {
        return;
      }

      // Logic: if step < 0 is TRUE, use OP_GTE; if FALSE (step >= 0), use
      // OP_LTE OP_JUMP_IF_FALSE jumps if the value is false, so:
      // - If step < 0 is FALSE (step >= 0): jump to LTE path
      // - If step < 0 is TRUE (step < 0): continue to GTE path
      size_t jump_to_lte_pos = emit_jump_with_offset(c, OP_JUMP_IF_FALSE);
      if (compiler_has_error(c)) {
        return;
      }

      // Step < 0 path: use OP_GTE
      // Stack: [var, end] (OP_JUMP_IF_FALSE popped the boolean)
      emit_byte(c, OP_GTE);
      if (compiler_has_error(c)) {
        return;
      }
      // Stack: [var >= end]
      size_t jump_after_comparison_pos = emit_jump_with_offset(c, OP_JUMP);
      if (compiler_has_error(c)) {
        return;
      }

      // Patch jump to LTE path
      size_t lte_path_start = c->bytecode->count;
      int16_t lte_offset = (int16_t)(lte_path_start - (jump_to_lte_pos + 2));
      if (lte_offset < INT16_MIN || lte_offset > INT16_MAX) {
        compiler_set_error(c, "Jump offset too large in for loop step check");
        return;
      }
      patch_jump_offset(c, jump_to_lte_pos, lte_offset);

      // Step >= 0 path: use OP_LTE
      // Stack: [var, end] (OP_JUMP_IF_FALSE popped the boolean)
      emit_byte(c, OP_LTE);
      if (compiler_has_error(c)) {
        return;
      }
      // Stack: [var <= end]

      // Patch jump after comparison
      size_t after_comparison = c->bytecode->count;
      int16_t after_offset =
          (int16_t)(after_comparison - (jump_after_comparison_pos + 2));
      if (after_offset < INT16_MIN || after_offset > INT16_MAX) {
        compiler_set_error(c, "Jump offset too large in for loop comparison");
        return;
      }
      patch_jump_offset(c, jump_after_comparison_pos, after_offset);
    } else {
      // Constant step or no step: use compile-time decision
      if (use_gte) {
        emit_byte(c, OP_GTE);
      } else {
        emit_byte(c, OP_LTE);
      }
    }
    if (compiler_has_error(c)) {
      return;
    }

    // Jump if false (exit loop)
    size_t exit_jump_pos = emit_jump_with_offset(c, OP_JUMP_IF_FALSE);
    if (compiler_has_error(c)) {
      return;
    }

    // Push loop info for break/continue
    if (!push_loop(c, loop_start)) {
      return;
    }

    // Compile loop body
    for (size_t i = 0; i < node->as.for_stmt.block_size; i++) {
      compile_statement(c, node->as.for_stmt.block[i]);
      if (compiler_has_error(c)) {
        pop_loop(c);
        return;
      }
    }

    // Set continue target to here (increment part) for continue statements
    if (c->loop_stack) {
      c->loop_stack->loop_continue = c->bytecode->count;
    }

    // Increment loop variable by step
    emit_byte(c, OP_LOAD_VAR);
    emit_uint16(c, (uint16_t)var_idx);
    if (compiler_has_error(c)) {
      pop_loop(c);
      return;
    }

    if (has_step) {
      // Use the specified step value
      compile_expression(c, node->as.for_stmt.step);
      if (compiler_has_error(c)) {
        pop_loop(c);
        return;
      }
    } else {
      // Default step is 1
      KronosValue *one = value_new_number(1);
      emit_constant(c, one);
      if (compiler_has_error(c)) {
        pop_loop(c);
        return;
      }
    }

    emit_byte(c, OP_ADD);
    emit_byte(c, OP_STORE_VAR);
    emit_uint16(c, (uint16_t)var_idx);
    emit_byte(c, 1);
    emit_byte(c, 0);
    if (compiler_has_error(c)) {
      pop_loop(c);
      return;
    }

    // Jump back to loop start
    size_t jump_back_pos = emit_jump_with_offset(c, OP_JUMP);
    if (compiler_has_error(c)) {
      pop_loop(c);
      return;
    }
    int16_t back_offset = (int16_t)(loop_start - (jump_back_pos + 2));
    if (back_offset < INT16_MIN || back_offset > INT16_MAX) {
      compiler_set_error(c, "Loop jump offset too large");
      pop_loop(c);
      return;
    }
    patch_jump_offset(c, jump_back_pos, back_offset);

    // Patch exit jump and update loop end
    size_t exit_target = c->bytecode->count;
    int16_t exit_offset = (int16_t)(exit_target - (exit_jump_pos + 2));
    if (exit_offset < 0 || exit_offset > INT16_MAX) {
      compiler_set_error(c, "Loop exit jump offset too large");
      pop_loop(c);
      return;
    }
    patch_jump_offset_unsigned(c, exit_jump_pos, (uint16_t)exit_offset);
    if (c->loop_stack) {
      c->loop_stack->loop_end = exit_target;
      // Patch all pending break/continue jumps
      patch_pending_jumps(c);
    }

    // Pop loop info
    pop_loop(c);
  } else {
    // List iteration: for item in list_expr
    // Compile list expression
    compile_expression(c, node->as.for_stmt.iterable);
    if (compiler_has_error(c)) {
      return;
    }

    // Start iteration - pushes [list, index=0] onto stack
    emit_byte(c, OP_LIST_ITER);
    if (compiler_has_error(c)) {
      return;
    }

    // Store iterator state in hidden variables to preserve across loop body
    // Create hidden variable names for iterator state
    // Use loop_counter to ensure uniqueness even for nested loops with same
    // var name
    char iter_list_name[64];
    char iter_index_name[64];
    snprintf(iter_list_name, sizeof(iter_list_name), "__iter_list_%zu_%zu",
             var_idx, c->loop_counter);
    snprintf(iter_index_name, sizeof(iter_index_name), "__iter_index_%zu_%zu",
             var_idx, c->loop_counter);

    // Stack after OP_LIST_ITER: [list, index] with index on top
    // Store index first (pops index)
    KronosValue *iter_index_name_val =
        value_new_string(iter_index_name, strlen(iter_index_name));
    size_t iter_index_name_idx = add_constant(c, iter_index_name_val);
    // add_constant() always takes ownership
    if (iter_index_name_idx == SIZE_MAX || iter_index_name_idx > UINT16_MAX) {
      return;
    }
    emit_byte(c, OP_STORE_VAR);
    emit_uint16(c, (uint16_t)iter_index_name_idx);
    emit_byte(c, 1); // mutable
    emit_byte(c, 0); // no type annotation
    if (compiler_has_error(c)) {
      return;
    }

    // Now store list (pops list)
    KronosValue *iter_list_name_val =
        value_new_string(iter_list_name, strlen(iter_list_name));
    size_t iter_list_name_idx = add_constant(c, iter_list_name_val);
    // add_constant() always takes ownership
    if (iter_list_name_idx == SIZE_MAX || iter_list_name_idx > UINT16_MAX) {
      return;
    }
    emit_byte(c, OP_STORE_VAR);
    emit_uint16(c, (uint16_t)iter_list_name_idx);
    emit_byte(c, 1); // mutable
    emit_byte(c, 0); // no type annotation
    if (compiler_has_error(c)) {
      return;
    }

    // Loop start
    size_t loop_start = c->bytecode->count;

    // Restore iterator state from variables
    emit_byte(c, OP_LOAD_VAR);
    emit_uint16(c, (uint16_t)iter_list_name_idx);
    if (compiler_has_error(c)) {
      return;
    }
    emit_byte(c, OP_LOAD_VAR);
    emit_uint16(c, (uint16_t)iter_index_name_idx);
    if (compiler_has_error(c)) {
      return;
    }
    // Stack: [list, index]

    // Get next item
    emit_byte(c, OP_LIST_NEXT);
    if (compiler_has_error(c)) {
      return;
    }

    // Stack after OP_LIST_NEXT: [list, index+1, item, has_more]
    // Check has_more flag (it's on top of stack)
    // Note: OP_JUMP_IF_FALSE pops the condition, so we don't need OP_POP
    size_t exit_jump_pos = emit_jump_with_offset(c, OP_JUMP_IF_FALSE);
    if (compiler_has_error(c)) {
      return;
    }

    // Push loop info for break/continue
    if (!push_loop(c, loop_start)) {
      return;
    }

    // Stack now: [list, index+1, item] (OP_JUMP_IF_FALSE already popped
    // has_more) Store item in loop variable (pops item)
    emit_byte(c, OP_STORE_VAR);
    emit_uint16(c, (uint16_t)var_idx);
    emit_byte(c, 1); // mutable
    emit_byte(c, 0); // no type annotation
    if (compiler_has_error(c)) {
      pop_loop(c);
      return;
    }

    // Stack now: [list, index+1] - save iterator state for next iteration
    // Stack is [list, index+1] with index+1 on top
    // Store updated index first (pops index+1)
    emit_byte(c, OP_STORE_VAR);
    emit_uint16(c, (uint16_t)iter_index_name_idx);
    emit_byte(c, 1); // mutable
    emit_byte(c, 0); // no type annotation
    if (compiler_has_error(c)) {
      pop_loop(c);
      return;
    }

    // Store list (pops list)
    emit_byte(c, OP_STORE_VAR);
    emit_uint16(c, (uint16_t)iter_list_name_idx);
    emit_byte(c, 1); // mutable
    emit_byte(c, 0); // no type annotation
    if (compiler_has_error(c)) {
      pop_loop(c);
      return;
    }

    // Stack is now empty - loop body can do whatever it wants

    // Compile loop body
    for (size_t i = 0; i < node->as.for_stmt.block_size; i++) {
      compile_statement(c, node->as.for_stmt.block[i]);
      if (compiler_has_error(c)) {
        pop_loop(c);
        return;
      }
    }

    // Jump back to loop start
    size_t jump_back_pos = emit_jump_with_offset(c, OP_JUMP);
    if (compiler_has_error(c)) {
      pop_loop(c);
      return;
    }
    int16_t back_offset = (int16_t)(loop_start - (jump_back_pos + 2));
    if (back_offset < INT16_MIN || back_offset > INT16_MAX) {
      compiler_set_error(c, "Loop jump offset too large");
      pop_loop(c);
      return;
    }
    patch_jump_offset(c, jump_back_pos, back_offset);

    // Patch exit jump and update loop end
    size_t exit_target = c->bytecode->count;
    int16_t exit_offset = (int16_t)(exit_target - (exit_jump_pos + 2));
    if (exit_offset < 0 || exit_offset > INT16_MAX) {
      compiler_set_error(c, "Loop exit jump offset too large");
      pop_loop(c);
      return;
    }
    patch_jump_offset_unsigned(c, exit_jump_pos, (uint16_t)exit_offset);
    if (c->loop_stack) {
      c->loop_stack->loop_end = exit_target;
      // Patch all pending break/continue jumps
      patch_pending_jumps(c);
    }

    // Pop loop info
    pop_loop(c);

    // Clean up: pop index and list from stack
    // Stack at exit: [list, index] (OP_JUMP_IF_FALSE already popped has_more)
    emit_byte(c, OP_POP); // pop index
    emit_byte(c, OP_POP); // pop list

    // Reset hidden iterator variables to null to release references
    KronosValue *nil_val = value_new_nil();
    emit_constant(c, nil_val);
    if (compiler_has_error(c)) {
      return;
    }
    emit_byte(c, OP_STORE_VAR);
    emit_uint16(c, (uint16_t)iter_list_name_idx);
    emit_byte(c, 1); // mutable
    emit_byte(c, 0); // no type annotation
    if (compiler_has_error(c)) {
      return;
    }

    nil_val = value_new_nil();
    emit_constant(c, nil_val);
    if (compiler_has_error(c)) {
      return;
    }
    emit_byte(c, OP_STORE_VAR);
    emit_uint16(c, (uint16_t)iter_index_name_idx);
    emit_byte(c, 1); // mutable
    emit_byte(c, 0); // no type annotation
    if (compiler_has_error(c)) {
      return;
    }
  }
}

/**
 * @brief Compile a while loop statement
 */
static void compile_while_statement(Compiler *c, const ASTNode *node) {
  // Loop start position (for break/continue jumps)
  size_t loop_start = c->bytecode->count;

  // Compile condition
  compile_expression(c, node->as.while_stmt.condition);
  if (compiler_has_error(c)) {
    return;
  }

  // Jump if false (exit loop)
  size_t exit_jump_pos = emit_jump_with_offset(c, OP_JUMP_IF_FALSE);
  if (compiler_has_error(c)) {
    return;
  }

  // Push loop info for break/continue
  if (!push_loop(c, loop_start)) {
    return;
  }

  // Compile loop body
  for (size_t i = 0; i < node->as.while_stmt.block_size; i++) {
    compile_statement(c, node->as.while_stmt.block[i]);
    if (compiler_has_error(c)) {
      pop_loop(c);
      return;
    }
  }

  // Jump back to loop start
  size_t jump_back_pos = emit_jump_with_offset(c, OP_JUMP);
  if (compiler_has_error(c)) {
    pop_loop(c);
    return;
  }
  int16_t back_offset = (int16_t)(loop_start - (jump_back_pos + 2));
  if (back_offset < INT16_MIN || back_offset > INT16_MAX) {
    compiler_set_error(c, "Loop jump offset too large");
    pop_loop(c);
    return;
  }
  patch_jump_offset(c, jump_back_pos, back_offset);

  // Patch exit jump and update loop end
  size_t exit_target = c->bytecode->count;
  int16_t exit_offset = (int16_t)(exit_target - (exit_jump_pos + 2));
  if (exit_offset < 0 || exit_offset > INT16_MAX) {
    compiler_set_error(c, "Loop exit jump offset too large");
    pop_loop(c);
    return;
  }
  patch_jump_offset_unsigned(c, exit_jump_pos, (uint16_t)exit_offset);
  if (c->loop_stack) {
    c->loop_stack->loop_end = exit_target;
    // Patch all pending break/continue jumps
    patch_pending_jumps(c);
  }

  // Pop loop info
  pop_loop(c);
}

/**
 * @brief Compile a function definition statement
 */
static void compile_function_statement(Compiler *c, const ASTNode *node) {
  // Store function name
  KronosValue *func_name =
      value_new_string(node->as.function.name, strlen(node->as.function.name));
  emit_byte(c, OP_DEFINE_FUNC);
  if (!emit_constant_index(c, func_name)) {
    return;
  }
  if (compiler_has_error(c)) {
    return;
  }
  // Validate parameter count limit (uint8_t max is 255)
  if (node->as.function.param_count > 255) {
    compiler_set_error(c, "Function parameter count exceeds limit (255)");
    return;
  }
  emit_byte(c, (uint8_t)node->as.function.param_count);
  if (compiler_has_error(c)) {
    return;
  }

  // Store parameter names as constants
  for (size_t i = 0; i < node->as.function.param_count; i++) {
    KronosValue *param_name = value_new_string(
        node->as.function.params[i], strlen(node->as.function.params[i]));
    if (!emit_constant_index(c, param_name)) {
      return;
    }
    if (compiler_has_error(c)) {
      return;
    }
  }

  // Store function body start position
  size_t body_start = c->bytecode->count + 2; // +2 for jump instruction
  emit_byte(c, (uint8_t)(body_start >> 8));   // High byte
  emit_byte(c, (uint8_t)(body_start & 0xFF)); // Low byte
  if (compiler_has_error(c)) {
    return;
  }

  // Emit jump over function body
  size_t skip_body_pos = emit_jump_with_offset(c, OP_JUMP);
  if (compiler_has_error(c)) {
    return;
  }

  // Compile function body
  for (size_t i = 0; i < node->as.function.block_size; i++) {
    compile_statement(c, node->as.function.block[i]);
    if (compiler_has_error(c)) {
      return;
    }
  }

  // Implicit return nil if no explicit return
  KronosValue *nil_val = value_new_nil();
  emit_constant(c, nil_val);
  if (compiler_has_error(c)) {
    return;
  }
  emit_byte(c, OP_RETURN_VAL);
  if (compiler_has_error(c)) {
    return;
  }

  // Patch jump over body
  if (compiler_has_error(c)) {
    return;
  }
  size_t func_end = c->bytecode->count;
  int16_t skip_offset = (int16_t)(func_end - (skip_body_pos + 2));
  if (skip_offset < 0 || skip_offset > INT16_MAX) {
    compiler_set_error(c, "Function body jump offset too large");
    return;
  }
  patch_jump_offset_unsigned(c, skip_body_pos, (uint16_t)skip_offset);
}

/**
 * @brief Compile a try-catch-finally statement
 */
static void compile_try_statement(Compiler *c, const ASTNode *node) {
  // Emit OP_TRY_ENTER to mark start of try block
  emit_byte(c, OP_TRY_ENTER);
  size_t try_start_pos = c->bytecode->count;
  emit_byte(c,
            0); // Placeholder for exception handler offset (will be patched)
  emit_byte(c, 0);

  // Compile try block
  for (size_t i = 0; i < node->as.try_stmt.try_block_size; i++) {
    compile_statement(c, node->as.try_stmt.try_block[i]);
    if (compiler_has_error(c)) {
      return;
    }
  }

  // Emit OP_TRY_EXIT to mark normal completion
  emit_byte(c, OP_TRY_EXIT);
  size_t finally_jump_pos = c->bytecode->count;
  emit_byte(c, 0); // Placeholder for finally jump offset
  emit_byte(c, 0);

  // Calculate exception handler position (catch or finally)
  size_t exception_handler_pos = c->bytecode->count;

  // Patch try_start_pos with exception handler offset
  size_t handler_offset = exception_handler_pos - (try_start_pos + 2);
  if (handler_offset > UINT16_MAX) {
    compiler_set_error(c, "Exception handler too far away");
    return;
  }
  c->bytecode->code[try_start_pos] = (uint8_t)((handler_offset >> 8) & 0xFF);
  c->bytecode->code[try_start_pos + 1] = (uint8_t)(handler_offset & 0xFF);

  // If catch blocks exist, emit catch handlers
  if (node->as.try_stmt.catch_block_count > 0) {
    // Emit OP_CATCH for first catch block
    emit_byte(c, OP_CATCH);

    // Store error type (NULL means catch all) and catch variable name as
    // constants
    const char *error_type = node->as.try_stmt.catch_blocks[0].error_type;
    const char *catch_var = node->as.try_stmt.catch_blocks[0].catch_var;

    // Error type constant (NULL if catch all)
    if (error_type) {
      KronosValue *error_type_val =
          value_new_string(error_type, strlen(error_type));
      if (!emit_constant_index(c, error_type_val)) {
        return;
      }
    } else {
      // Catch all - use 0xFFFF as marker
      emit_uint16(c, 0xFFFF);
    }

    // Catch variable name constant - OP_CATCH will push error onto stack
    // Then we emit OP_STORE_VAR to create the catch variable
    if (catch_var) {
      KronosValue *catch_var_val =
          value_new_string(catch_var, strlen(catch_var));
      size_t catch_var_idx = add_constant(c, catch_var_val);
      // add_constant() always takes ownership
      if (catch_var_idx == SIZE_MAX || catch_var_idx > UINT16_MAX) {
        return;
      }
      emit_uint16(c, (uint16_t)catch_var_idx);

      // After OP_CATCH pushes error onto stack, store it as variable
      emit_byte(c, OP_STORE_VAR);
      emit_uint16(c, (uint16_t)catch_var_idx);
      emit_byte(c, 1); // is_mutable = true
      emit_byte(c, 0); // No type annotation
    } else {
      emit_uint16(c, 0xFFFF); // No variable
    }

    // Compile first catch block
    for (size_t i = 0; i < node->as.try_stmt.catch_blocks[0].catch_block_size;
         i++) {
      compile_statement(c, node->as.try_stmt.catch_blocks[0].catch_block[i]);
      if (compiler_has_error(c)) {
        return;
      }
    }

    // Compile additional catch blocks (if any)
    for (size_t cb = 1; cb < node->as.try_stmt.catch_block_count; cb++) {
      emit_byte(c, OP_CATCH);

      error_type = node->as.try_stmt.catch_blocks[cb].error_type;
      catch_var = node->as.try_stmt.catch_blocks[cb].catch_var;

      if (error_type) {
        KronosValue *error_type_val =
            value_new_string(error_type, strlen(error_type));
        if (!emit_constant_index(c, error_type_val)) {
          return;
        }
      } else {
        emit_uint16(c, 0xFFFF);
      }

      if (catch_var) {
        KronosValue *catch_var_val =
            value_new_string(catch_var, strlen(catch_var));
        size_t catch_var_idx = add_constant(c, catch_var_val);
        // add_constant() always takes ownership
        if (catch_var_idx == SIZE_MAX || catch_var_idx > UINT16_MAX) {
          return;
        }
        emit_uint16(c, (uint16_t)catch_var_idx);

        // After OP_CATCH pushes error onto stack, store it as variable
        emit_byte(c, OP_STORE_VAR);
        emit_uint16(c, (uint16_t)catch_var_idx);
        emit_byte(c, 1); // is_mutable = true
        emit_byte(c, 0); // No type annotation
      } else {
        emit_uint16(c, 0xFFFF);
      }

      // Compile catch block
      for (size_t i = 0;
           i < node->as.try_stmt.catch_blocks[cb].catch_block_size; i++) {
        compile_statement(c, node->as.try_stmt.catch_blocks[cb].catch_block[i]);
        if (compiler_has_error(c)) {
          return;
        }
      }
    }
  }

  // If finally exists, emit finally handler
  if (node->as.try_stmt.finally_block) {
    size_t finally_start_pos = c->bytecode->count;

    // Patch OP_TRY_EXIT to jump to finally
    size_t finally_offset = finally_start_pos - (finally_jump_pos + 2);
    if (finally_offset > UINT16_MAX) {
      compiler_set_error(c, "Finally block too far away");
      return;
    }
    c->bytecode->code[finally_jump_pos] =
        (uint8_t)((finally_offset >> 8) & 0xFF);
    c->bytecode->code[finally_jump_pos + 1] = (uint8_t)(finally_offset & 0xFF);

    emit_byte(c, OP_FINALLY);

    // Compile finally block
    for (size_t i = 0; i < node->as.try_stmt.finally_block_size; i++) {
      compile_statement(c, node->as.try_stmt.finally_block[i]);
      if (compiler_has_error(c)) {
        return;
      }
    }
  } else {
    // No finally, patch OP_TRY_EXIT to jump past exception handler
    size_t skip_offset = c->bytecode->count - (finally_jump_pos + 2);
    if (skip_offset > UINT16_MAX) {
      compiler_set_error(c, "Try block too large");
      return;
    }
    c->bytecode->code[finally_jump_pos] = (uint8_t)((skip_offset >> 8) & 0xFF);
    c->bytecode->code[finally_jump_pos + 1] = (uint8_t)(skip_offset & 0xFF);
  }
}

/**
 * @brief Compile a statement AST node to bytecode
 *
 * Handles all statement types: assignments, prints, conditionals,
 * loops, functions, returns, etc.
 *
 * @param c Compiler state
 * @param node Statement AST node to compile (not modified)
 */
static void compile_statement(Compiler *c, const ASTNode *node) {
  if (!node || compiler_has_error(c)) {
    return;
  }

  switch (node->type) {
  case AST_ASSIGN:
    compile_assign_statement(c, node);
    break;

  case AST_ASSIGN_INDEX:
    compile_assign_index_statement(c, node);
    break;

  case AST_DELETE:
    compile_delete_statement(c, node);
    break;

  case AST_TRY:
    compile_try_statement(c, node);
    break;

  case AST_PRINT:
    compile_print_statement(c, node);
    break;

  case AST_RAISE:
    compile_raise_statement(c, node);
    break;

  case AST_IF:
    compile_if_statement(c, node);
    break;

  case AST_FOR:
    compile_for_statement(c, node);
    break;

  case AST_WHILE:
    compile_while_statement(c, node);
    break;

  case AST_FUNCTION:
    compile_function_statement(c, node);
    break;

  case AST_CALL:
    compile_call_statement(c, node);
    break;

  case AST_IMPORT:
    compile_import_statement(c, node);
    break;

  case AST_BREAK:
    compile_break_statement(c, node);
    break;

  case AST_CONTINUE:
    compile_continue_statement(c, node);
    break;

  case AST_RETURN:
    compile_return_statement(c, node);
    break;

  // Expression nodes can be used as statements (for REPL expression evaluation)
  // Compile the expression and leave the value on the stack
  case AST_NUMBER:
  case AST_STRING:
  case AST_FSTRING:
  case AST_BOOL:
  case AST_NULL:
  case AST_VAR:
  case AST_BINOP:
  case AST_LIST:
  case AST_RANGE:
  case AST_MAP:
  case AST_INDEX:
  case AST_SLICE:
    compile_expression(c, node);
    break;

  default:
    compiler_set_error(c, "Unknown statement node type");
    break;
  }
}

/**
 * @brief Compile an AST to bytecode
 *
 * Main entry point for compilation. Processes all statements in the AST
 * and generates executable bytecode. Emits a HALT instruction at the end.
 *
 * @param ast Abstract Syntax Tree to compile
 * @param out_err Optional pointer to receive error message
 * @return Generated bytecode, or NULL on error
 */
Bytecode *compile(AST *ast, const char **out_err) {
  if (out_err) {
    *out_err = NULL;
  }
  if (!ast) {
    if (out_err) {
      *out_err = "Invalid AST (NULL)";
    }
    return NULL;
  }

  Compiler *c = calloc(1, sizeof(Compiler));
  if (!c) {
    if (out_err) {
      *out_err = "Failed to allocate compiler";
    }
    return NULL;
  }
  c->to_string_const_idx = SIZE_MAX;
  c->loop_counter = 0;
  c->bytecode = malloc(sizeof(Bytecode));
  if (!c->bytecode) {
    free(c);
    if (out_err) {
      *out_err = "Failed to allocate bytecode structure";
    }
    return NULL;
  }

  // Initialize bytecode
  c->bytecode->capacity = BYTECODE_INITIAL_CAPACITY;
  c->bytecode->count = 0;
  c->bytecode->code = malloc(c->bytecode->capacity);
  if (!c->bytecode->code) {
    free(c->bytecode);
    free(c);
    if (out_err) {
      *out_err = "Failed to allocate bytecode buffer";
    }
    return NULL;
  }

  c->bytecode->const_capacity = CONSTANT_POOL_DEFAULT_CAPACITY;
  c->bytecode->const_count = 0;
  c->bytecode->constants =
      calloc(c->bytecode->const_capacity, sizeof(KronosValue *));
  if (!c->bytecode->constants) {
    free(c->bytecode->code);
    free(c->bytecode);
    free(c);
    if (out_err) {
      *out_err = "Failed to allocate constant pool";
    }
    return NULL;
  }

  // Compile all statements
  for (size_t i = 0; i < ast->count && !compiler_has_error(c); i++) {
    compile_statement(c, ast->statements[i]);
  }

  // Emit halt instruction if no errors occurred
  if (!compiler_has_error(c)) {
    emit_byte(c, OP_HALT);
  }

  if (compiler_has_error(c)) {
    if (out_err) {
      *out_err = c->error_message ? c->error_message : "Compilation failed";
    }
    bytecode_free(c->bytecode);
    // Free loop stack if any
    while (c->loop_stack) {
      LoopInfo *next = c->loop_stack->next;
      free(c->loop_stack);
      c->loop_stack = next;
    }
    free(c);
    return NULL;
  }

  Bytecode *result = c->bytecode;
  free(c);
  return result;
}

/**
 * @brief Free bytecode and its constant pool
 *
 * Releases all constants and the bytecode structure itself.
 *
 * @param bytecode Bytecode to free (safe to pass NULL)
 */
void bytecode_free(Bytecode *bytecode) {
  if (!bytecode) {
    return;
  }

  // Validate const_count before freeing
  if (bytecode->const_count > bytecode->const_capacity) {
    fprintf(stderr, "WARNING: const_count (%zu) > const_capacity (%zu)\n",
            bytecode->const_count, bytecode->const_capacity);
    bytecode->const_count = bytecode->const_capacity;
  }

  // Free constants
  for (size_t i = 0; i < bytecode->const_capacity; i++) {
    if (bytecode->constants[i]) {
      value_release(bytecode->constants[i]);
    }
  }

  free(bytecode->constants);
  free(bytecode->code);
  free(bytecode);
}

/**
 * @brief Print bytecode in human-readable format
 *
 * Useful for debugging compilation. Shows constants and disassembled
 * instructions with their operands.
 *
 * @param bytecode Bytecode to print
 */
void bytecode_print(Bytecode *bytecode) {
  if (!bytecode) {
    printf("Bytecode: NULL\n");
    return;
  }

  printf("=== Bytecode ===\n");
  printf("Constants (%zu):\n", bytecode->const_count);
  for (size_t i = 0; i < bytecode->const_count; i++) {
    printf("  [%zu] ", i);
    value_fprint(stdout, bytecode->constants[i]);
    printf("\n");
  }

  printf("\nInstructions (%zu bytes):\n", bytecode->count);
  size_t offset = 0;
  while (offset < bytecode->count) {
    printf("%04zu  ", offset);
    uint8_t instruction = bytecode->code[offset];

    switch (instruction) {
    case OP_LOAD_CONST: {
      if (offset + 2 >= bytecode->count) {
        printf("LOAD_CONST <invalid: out of bounds>\n");
        offset = bytecode->count;
        break;
      }
      uint16_t idx = (uint16_t)(bytecode->code[offset + 1] << 8 |
                                bytecode->code[offset + 2]);
      printf("LOAD_CONST %u\n", idx);
      offset += 3;
      break;
    }
    case OP_LOAD_VAR: {
      if (offset + 2 >= bytecode->count) {
        printf("LOAD_VAR <invalid: out of bounds>\n");
        offset = bytecode->count;
        break;
      }
      uint16_t idx = (uint16_t)(bytecode->code[offset + 1] << 8 |
                                bytecode->code[offset + 2]);
      printf("LOAD_VAR %u\n", idx);
      offset += 3;
      break;
    }
    case OP_STORE_VAR: {
      if (offset + 4 >= bytecode->count) {
        printf("STORE_VAR <invalid: out of bounds>\n");
        offset = bytecode->count;
        break;
      }
      uint16_t idx = (uint16_t)(bytecode->code[offset + 1] << 8 |
                                bytecode->code[offset + 2]);
      uint8_t is_mutable = bytecode->code[offset + 3];
      uint8_t has_type = bytecode->code[offset + 4];
      printf("STORE_VAR name=%u mutable=%u", idx, is_mutable);
      offset += 5;
      if (has_type) {
        if (offset + 1 >= bytecode->count) {
          printf(" <invalid: type index out of bounds>\n");
          offset = bytecode->count;
          break;
        }
        uint16_t type_idx = (uint16_t)(bytecode->code[offset] << 8 |
                                       bytecode->code[offset + 1]);
        printf(" type=%u", type_idx);
        offset += 2;
      }
      printf("\n");
      break;
    }
    case OP_PRINT:
      printf("PRINT\n");
      offset++;
      break;
    case OP_ADD:
      printf("ADD\n");
      offset++;
      break;
    case OP_SUB:
      printf("SUB\n");
      offset++;
      break;
    case OP_MUL:
      printf("MUL\n");
      offset++;
      break;
    case OP_DIV:
      printf("DIV\n");
      offset++;
      break;
    case OP_MOD:
      printf("MOD\n");
      offset++;
      break;
    case OP_NEG:
      printf("NEG\n");
      offset++;
      break;
    case OP_EQ:
      printf("EQ\n");
      offset++;
      break;
    case OP_NEQ:
      printf("NEQ\n");
      offset++;
      break;
    case OP_GT:
      printf("GT\n");
      offset++;
      break;
    case OP_LT:
      printf("LT\n");
      offset++;
      break;
    case OP_GTE:
      printf("GTE\n");
      offset++;
      break;
    case OP_LTE:
      printf("LTE\n");
      offset++;
      break;
    case OP_AND:
      printf("AND\n");
      offset++;
      break;
    case OP_OR:
      printf("OR\n");
      offset++;
      break;
    case OP_NOT:
      printf("NOT\n");
      offset++;
      break;
    case OP_JUMP: {
      if (offset + 2 >= bytecode->count) {
        printf("JUMP <invalid: out of bounds>\n");
        offset = bytecode->count;
        break;
      }
      int16_t jump_offset = (int16_t)((bytecode->code[offset + 1] << 8) |
                                      bytecode->code[offset + 2]);
      printf("JUMP %d\n", jump_offset);
      offset += 3;
      break;
    }
    case OP_JUMP_IF_FALSE: {
      if (offset + 2 >= bytecode->count) {
        printf("JUMP_IF_FALSE <invalid: out of bounds>\n");
        offset = bytecode->count;
        break;
      }
      uint16_t jump_offset = (uint16_t)((bytecode->code[offset + 1] << 8) |
                                        bytecode->code[offset + 2]);
      printf("JUMP_IF_FALSE %u\n", jump_offset);
      offset += 3;
      break;
    }
    case OP_DEFINE_FUNC: {
      if (offset + 3 >= bytecode->count) {
        printf("DEFINE_FUNC <invalid: out of bounds>\n");
        offset = bytecode->count;
        break;
      }
      uint16_t name_idx = (uint16_t)(bytecode->code[offset + 1] << 8 |
                                     bytecode->code[offset + 2]);
      uint8_t param_count = bytecode->code[offset + 3];
      size_t skip = 4 + (size_t)param_count * 2 + 2 + 2;
      if (offset + skip > bytecode->count) {
        printf("DEFINE_FUNC %u (param_count=%u) <invalid: parameters out of "
               "bounds>\n",
               name_idx, param_count);
        offset = bytecode->count;
        break;
      }
      printf("DEFINE_FUNC %u (param_count=%u)\n", name_idx, param_count);
      offset += skip;
      break;
    }
    case OP_CALL_FUNC: {
      if (offset + 3 >= bytecode->count) {
        printf("CALL_FUNC <invalid: out of bounds>\n");
        offset = bytecode->count;
        break;
      }
      uint16_t name_idx = (uint16_t)(bytecode->code[offset + 1] << 8 |
                                     bytecode->code[offset + 2]);
      uint8_t arg_count = bytecode->code[offset + 3];
      printf("CALL_FUNC %u (arg_count=%u)\n", name_idx, arg_count);
      offset += 4;
      break;
    }
    case OP_RETURN_VAL:
      printf("RETURN_VAL\n");
      offset++;
      break;
    case OP_POP:
      printf("POP\n");
      offset++;
      break;

    case OP_LIST_NEW: {
      if (offset + 2 >= bytecode->count) {
        printf("LIST_NEW <invalid: out of bounds>\n");
        offset = bytecode->count;
        break;
      }
      uint16_t count = (uint16_t)(bytecode->code[offset + 1] << 8 |
                                  bytecode->code[offset + 2]);
      printf("LIST_NEW %u\n", count);
      offset += 3;
      break;
    }

    case OP_LIST_GET:
      printf("LIST_GET\n");
      offset++;
      break;

    case OP_LIST_SET:
      printf("LIST_SET\n");
      offset++;
      break;

    case OP_LIST_APPEND:
      printf("LIST_APPEND\n");
      offset++;
      break;

    case OP_LIST_LEN:
      printf("LIST_LEN\n");
      offset++;
      break;

    case OP_LIST_SLICE:
      printf("LIST_SLICE\n");
      offset++;
      break;

    case OP_LIST_ITER:
      printf("LIST_ITER\n");
      offset++;
      break;

    case OP_LIST_NEXT:
      printf("LIST_NEXT\n");
      offset++;
      break;

    case OP_RANGE_NEW:
      printf("RANGE_NEW\n");
      offset++;
      break;

    case OP_MAP_NEW: {
      if (offset + 2 >= bytecode->count) {
        printf("MAP_NEW <invalid: out of bounds>\n");
        offset = bytecode->count;
        break;
      }
      uint16_t count = (uint16_t)(bytecode->code[offset + 1] << 8 |
                                  bytecode->code[offset + 2]);
      printf("MAP_NEW %u\n", count);
      offset += 3;
      break;
    }

    case OP_MAP_SET:
      printf("MAP_SET\n");
      offset++;
      break;

    case OP_MAP_GET:
      printf("MAP_GET\n");
      offset++;
      break;

    case OP_DELETE:
      printf("DELETE\n");
      offset++;
      break;

    case OP_TRY_ENTER: {
      if (offset + 2 >= bytecode->count) {
        printf("TRY_ENTER <invalid: out of bounds>\n");
        offset = bytecode->count;
        break;
      }
      uint16_t handler_offset = (uint16_t)(bytecode->code[offset + 1] << 8 |
                                           bytecode->code[offset + 2]);
      printf("TRY_ENTER handler_offset=%u\n", handler_offset);
      offset += 3;
      break;
    }

    case OP_TRY_EXIT: {
      if (offset + 2 >= bytecode->count) {
        printf("TRY_EXIT <invalid: out of bounds>\n");
        offset = bytecode->count;
        break;
      }
      uint16_t finally_offset = (uint16_t)(bytecode->code[offset + 1] << 8 |
                                           bytecode->code[offset + 2]);
      printf("TRY_EXIT finally_offset=%u\n", finally_offset);
      offset += 3;
      break;
    }

    case OP_CATCH: {
      if (offset + 4 >= bytecode->count) {
        printf("CATCH <invalid: out of bounds>\n");
        offset = bytecode->count;
        break;
      }
      uint16_t error_type_idx = (uint16_t)(bytecode->code[offset + 1] << 8 |
                                           bytecode->code[offset + 2]);
      uint16_t catch_var_idx = (uint16_t)(bytecode->code[offset + 3] << 8 |
                                          bytecode->code[offset + 4]);
      printf("CATCH error_type=%u catch_var=%u\n", error_type_idx,
             catch_var_idx);
      offset += 5;
      break;
    }

    case OP_FINALLY:
      printf("FINALLY\n");
      offset++;
      break;

    case OP_THROW: {
      if (offset + 2 >= bytecode->count) {
        printf("THROW <invalid: out of bounds>\n");
        offset = bytecode->count;
        break;
      }
      uint16_t error_type_idx = (uint16_t)(bytecode->code[offset + 1] << 8 |
                                           bytecode->code[offset + 2]);
      printf("THROW error_type=%u\n", error_type_idx);
      offset += 3;
      break;
    }

    case OP_IMPORT: {
      if (offset + 4 >= bytecode->count) {
        printf("IMPORT <invalid: out of bounds>\n");
        offset = bytecode->count;
        break;
      }
      uint16_t module_name_idx = (uint16_t)(bytecode->code[offset + 1] << 8 |
                                            bytecode->code[offset + 2]);
      uint16_t file_path_idx = (uint16_t)(bytecode->code[offset + 3] << 8 |
                                          bytecode->code[offset + 4]);
      printf("IMPORT module=%u file_path=%u\n", module_name_idx, file_path_idx);
      offset += 5;
      break;
    }

    case OP_HALT:
      printf("HALT\n");
      offset++;
      break;
    default:
      printf("UNKNOWN (%d)\n", instruction);
      offset++;
      break;
    }
  }
}
